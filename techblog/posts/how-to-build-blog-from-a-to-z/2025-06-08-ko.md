# LaTeX 컴파일부터 디자인까지 블로그를 직접 만드는 방법

----------------------------------------------------------------------

# 1. 굳이 왜?

2023년 8월부터 2025년 6월까지 1년 10개월 동안 나는 jekyll로 만든 기술 블로그를 작성해왔다. 처음 블로그를 작성하기 시작할 당시에 어떤 양식으로 작성할지에 대해 많이 고민했었다.

1. Naver Blog
2. Velog
3. Tistory
4. Jekyll + Github.io

나는 이 중에서 4. Jekyll + Github.io를 선택했다. 가장 자유도가 높았으며, LaTeX를 작성하기에 가장 용의했기 때문이다. Jekyll은 사용자가 blog posting을 쉽게 할 수 있도록 하기 위해 만들어진 framework다. Github,io를 통해 무료로 hosting하여 배포할 수 있다. 하지만 나는 Jekyll에서도 다음과 같은 문제 의식을 많이 느꼈다.

1. 디자인을 큰 수준에서 바꿀 수 없다.
2. Jekyll에서 제공해주는 기능 외에 추가적인 기능을 위해서는 직접 개발해야 한다.
3. 의존성 덩어리이기 때문에 특정 부분을 수정할 때 오류가 많이 난다.

----------------------------------------------------------------------

# 2. 프로젝트

## 목표

기술 블로그에는 수식적 표현이 많이 들어간다. 일반적으로 LaTeX라는 문법을 이용한다.

폴더 이름, 파일 이름, 메타 정보들이 그대로 반영된다.

## 디자인 원칙과 목표

1. 부가적인 기능을 최대한 배제하여 단순하고 직관적인 블로그를 만든다.
2. 반드시 필요한 기능들을 정교하게 만들어서 미를 전달하자. 예를 들어 글꼴과 글자색, 화면이 깨지지 않는 코드블록, 잘 표현된 테이블 등이 있다.
3. 개발자스러운 디자인이지만 modern한 느낌을 사용한다. 검정 바탕에 흰(또는 초록색) 글씨가 있는 Terminal을 motive로 사용한다.
4. 굉장히 자유도가 높은 블로그를 만든다.
5. 코딩을 어려워하는 사람도 어려움 없이 사용할 수 있는 블로그를 만든다.
6. 프레임워크나 라이브러리와 같은 어떠한 의존성도 사용하지 않는다. Markdown과 LaTeX를 HTML과 CSS로 변환해주는 컴파일러를 포함하여 모든 것을 직접 개발한다.

## 기능 정의

## 기술스택

HTML, CSS, and Javascript is all you need.

no 의존성, no 프레임워크, no 라이브러리.

## 과정

1. compiler transforming Markdown to HTML
2. compiler transforming LaTex to HTML

----------------------------------------------------------------------

# 3. SPA

Single Page Application

사실상 root path에 있는 index.html에서 모든 처리가 진행된다.

## 세부 고려 사항

Post Meta Data

1. Title -> folder name in kebab-case, e.g. `making-personal-blog`
2. Date -> markdown file name, e.g. `2025-07-09-en.md`
3. Language (ko, en) -> markdown file name
4. Categories -> Markdown의 YAML Front Matter

js로 folder 구조를 탐색하기 위해서는 json 등의 meta data도 별도로 관리해야 한다.

로컬 테스트용이라면 폴더 내 파일명을 직접 알고 있어서 위 코드처럼 직접 지정 가능하지만 실제 서비스라면 빌드/배포 스크립트로 메타데이터 JSON 만들고, SPA가 그걸 참고하도록 구현해야 한다.

브라우저(클라이언트)에서 실시간으로 로컬 혹은 웹서버 내 폴더 구조를 직접 읽고 파일 목록을 가져오는 것은 보안상의 이유로 불가능합니다.

Node.js 스크립트나 배포 스크립트가 posts/ 폴더를 스캔해서

게시물 메타데이터(JSON)를 만들어 둠

JavaScript (클라이언트 측)는 posts/ 디렉토리 내부 구조를 실시간으로 탐색할 수 없기 때문에, 수동으로 혹은 자동으로 작성된 `posts-meta.json` 파일이 반드시 필요하다.

----------------------------------------------------------------------

# 3. JSON을 이용한 폴더와 파일, 메타 데이터 파싱

----------------------------------------------------------------------

# 4. Markdown to HTML

Markdown의 문법과 HTML의 문법이 대응되는 것을 정확히 정의해야 한다.

1 Headers

`#`와 `<h1>`
`##`와 `<h2>`
`###`와 `<h3>`

2 Ordered Lists

```
1. first
2. second
3. third
```

```html
<ol><li>...</li></ol>
```

3 Code Block

```
int main(void) {
    return 0;
}
```

----------------------------------------------------------------------  

# 5. LaTeX to HTML

LaTeX란 무엇인가?

MathJax와 같은 외부 라이브러리를 사용하지 않고 LaTeX를 HTML로 작접 변환하는 컴파일러를 만든다.

나는 LaTeX를 HTML과 CSS로만 랜더링하는 방식을 채택한다. (마치 MathJax에서 CommonHTML과 같이)

1. 토큰화: 문자 분해 -> 토큰 생성
2. 파싱을 통한 추상 문법 트리 생성: 토큰 -> AST 생성
3. 레이아웃 계산: 각 노드 크기 및 위치 산출
4. 렌더링: HTML과 CSS, SVG 요소 생성

다음과 같은 LaTeX로 작성된 식이 있다고 하자.

$$
\ddot{X} + \dfrac{3}{t} \dot{X} + \nabla f(X) = 0
$$

토큰화

1. 명령어(\ddot, \dfrac, \dot, \nabla)는 \로 시작해서 알파벳이 이어지는 부분 전체를 하나의 토큰으로 인식
2. 중괄호 { }는 그룹핑을 위해 각각 별도 토큰
3. 변수와 숫자는 알파벳, 숫자 단위로 분리
4. 연산자 및 괄호(+, =, (, ))는 각각 하나의 토큰
5. 공백은 무시하거나 토큰 분리의 기준으로 활용

파싱을 통해 추상 문법 트리 생성

    Equal
    ├── Add
    │   ├── DoubleDot
    │   │   └── X
    │   ├── Multiply
    │   │   ├── Fraction
    │   │   │   ├── 3
    │   │   │   └── t
    │   │   └── Dot
    │   │       └── X
    │   └── Gradient
    │       └── FunctionCall
    │           ├── f
    │           └── X
    └── 0

레이아웃 계산: 각 노드 크기 및 위치 산출

1. 노드 크기 계산	폰트, 연산자, 자식 노드 크기 기반 너비/높이 결정
2. 상대 위치 계산	자식 간의 정렬 방식 (수평/수직) 지정
3. 기준선 정렬	다른 수식과 시각적으로 어긋나지 않도록 베이스라인 정렬
4. 최종 위치 부여	각 노드에 (x, y) 위치 지정해서 렌더링 가능하게 함